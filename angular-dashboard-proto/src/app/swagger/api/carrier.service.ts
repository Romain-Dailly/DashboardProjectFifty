/**
 * Fifty Truck API
 * This is the API of fifty truck
 *
 * OpenAPI spec version: 0.1.0
 * Contact: contact@fiftytruck.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { Body } from '../model/Body';
import { Login1 } from '../model/Login1';
import { Login2 } from '../model/Login2';
import { MailContact } from '../model/MailContact';
import { Marketplace } from '../model/Marketplace';
import { MarketplaceMetadata } from '../model/MarketplaceMetadata';
import { MarketplaceOffer } from '../model/MarketplaceOffer';
import { MarketplaceOfferDetail } from '../model/MarketplaceOfferDetail';
import { MarketplaceOfferPublication } from '../model/MarketplaceOfferPublication';
import { MarketplaceUser } from '../model/MarketplaceUser';
import { Operator } from '../model/Operator';
import { OperatorUser } from '../model/OperatorUser';
import { RegisterCarrier } from '../model/RegisterCarrier';
import { RouteWaypoint } from '../model/RouteWaypoint';
import { Routes } from '../model/Routes';
import { SeizedShippingOrder } from '../model/SeizedShippingOrder';
import { ShipperScore } from '../model/ShipperScore';
import { ShippingOrderGrouping } from '../model/ShippingOrderGrouping';
import { ShippingOrderResult } from '../model/ShippingOrderResult';
import { ShippingOrderResultsNewOfferCount } from '../model/ShippingOrderResultsNewOfferCount';
import { ShippingOrderSearch } from '../model/ShippingOrderSearch';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ApiCarrierService {

    protected basePath = 'http://api-inte.fiftytruck.com/api/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Create new MarketplaceOffer
     * 
     * @param body MarketplaceOffer object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addMarketplaceOffer(body: MarketplaceOffer, observe?: 'body', reportProgress?: boolean): Observable<MarketplaceOffer>;
    public addMarketplaceOffer(body: MarketplaceOffer, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MarketplaceOffer>>;
    public addMarketplaceOffer(body: MarketplaceOffer, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MarketplaceOffer>>;
    public addMarketplaceOffer(body: MarketplaceOffer, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addMarketplaceOffer.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<MarketplaceOffer>(`${this.basePath}/marketplaceOffer`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create new operator
     * 
     * @param body Operator object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addOperator(body: OperatorUser, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addOperator(body: OperatorUser, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addOperator(body: OperatorUser, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addOperator(body: OperatorUser, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addOperator.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/operator`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add new waypoint on given search route
     * 
     * @param shippingOrderSearchId Search id to patch
     * @param body RouteWaypoint
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addRouteWaypointToSearchRoute(shippingOrderSearchId: number, body: RouteWaypoint, observe?: 'body', reportProgress?: boolean): Observable<ShippingOrderSearch>;
    public addRouteWaypointToSearchRoute(shippingOrderSearchId: number, body: RouteWaypoint, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ShippingOrderSearch>>;
    public addRouteWaypointToSearchRoute(shippingOrderSearchId: number, body: RouteWaypoint, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ShippingOrderSearch>>;
    public addRouteWaypointToSearchRoute(shippingOrderSearchId: number, body: RouteWaypoint, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderSearchId === null || shippingOrderSearchId === undefined) {
            throw new Error('Required parameter shippingOrderSearchId was null or undefined when calling addRouteWaypointToSearchRoute.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addRouteWaypointToSearchRoute.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ShippingOrderSearch>(`${this.basePath}/shippingOrderSearch/${encodeURIComponent(String(shippingOrderSearchId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set score for given shipper company name
     * 
     * @param body ShipperScore object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addShipperScore(body: ShipperScore, observe?: 'body', reportProgress?: boolean): Observable<ShipperScore>;
    public addShipperScore(body: ShipperScore, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ShipperScore>>;
    public addShipperScore(body: ShipperScore, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ShipperScore>>;
    public addShipperScore(body: ShipperScore, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addShipperScore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ShipperScore>(`${this.basePath}/shipperScore`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add shipping orders search
     * 
     * @param body ShippingOrderSearch
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addShippingOrderSearch(body: ShippingOrderSearch, observe?: 'body', reportProgress?: boolean): Observable<ShippingOrderSearch>;
    public addShippingOrderSearch(body: ShippingOrderSearch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ShippingOrderSearch>>;
    public addShippingOrderSearch(body: ShippingOrderSearch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ShippingOrderSearch>>;
    public addShippingOrderSearch(body: ShippingOrderSearch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addShippingOrderSearch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ShippingOrderSearch>(`${this.basePath}/shippingOrderSearch`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete given MarketplaceOffer and withdraw from all Marketplaces
     * 
     * @param marketplaceOfferId Id of the MarketplaceOffer to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteMarketplaceOffer(marketplaceOfferId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteMarketplaceOffer(marketplaceOfferId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteMarketplaceOffer(marketplaceOfferId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteMarketplaceOffer(marketplaceOfferId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (marketplaceOfferId === null || marketplaceOfferId === undefined) {
            throw new Error('Required parameter marketplaceOfferId was null or undefined when calling deleteMarketplaceOffer.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/marketplaceOffer/${encodeURIComponent(String(marketplaceOfferId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete marketplaceUser
     * 
     * @param marketplaceId MarketplaceUser id to delete
     * @param userId User id to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteMarketplaceUser(marketplaceId: number, userId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteMarketplaceUser(marketplaceId: number, userId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteMarketplaceUser(marketplaceId: number, userId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteMarketplaceUser(marketplaceId: number, userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (marketplaceId === null || marketplaceId === undefined) {
            throw new Error('Required parameter marketplaceId was null or undefined when calling deleteMarketplaceUser.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteMarketplaceUser.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/marketplace/${encodeURIComponent(String(marketplaceId))}/userId/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete operator
     * 
     * @param operatorId Operator id to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteOperator(operatorId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteOperator(operatorId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteOperator(operatorId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteOperator(operatorId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (operatorId === null || operatorId === undefined) {
            throw new Error('Required parameter operatorId was null or undefined when calling deleteOperator.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/operator/${encodeURIComponent(String(operatorId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete ShipperScore
     * 
     * @param shipperCompanyName Remove score for this (urlencoded) Shipper Company Name
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteShipperScore(shipperCompanyName: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteShipperScore(shipperCompanyName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteShipperScore(shipperCompanyName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteShipperScore(shipperCompanyName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shipperCompanyName === null || shipperCompanyName === undefined) {
            throw new Error('Required parameter shipperCompanyName was null or undefined when calling deleteShipperScore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/shipperScore/${encodeURIComponent(String(shipperCompanyName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete shipping orders search
     * 
     * @param shippingOrderSearchId Search id to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteShippingOrderSearch(shippingOrderSearchId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteShippingOrderSearch(shippingOrderSearchId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteShippingOrderSearch(shippingOrderSearchId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteShippingOrderSearch(shippingOrderSearchId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderSearchId === null || shippingOrderSearchId === undefined) {
            throw new Error('Required parameter shippingOrderSearchId was null or undefined when calling deleteShippingOrderSearch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/shippingOrderSearch/${encodeURIComponent(String(shippingOrderSearchId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete multiple shipping orders searches
     * 
     * @param shippingOrderSearchIds Search id to delete (format: shippingOrderSearchIds&#x3D;123;456;789)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteShippingOrderSearchs(shippingOrderSearchIds: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteShippingOrderSearchs(shippingOrderSearchIds: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteShippingOrderSearchs(shippingOrderSearchIds: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteShippingOrderSearchs(shippingOrderSearchIds: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderSearchIds === null || shippingOrderSearchIds === undefined) {
            throw new Error('Required parameter shippingOrderSearchIds was null or undefined when calling deleteShippingOrderSearchs.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (shippingOrderSearchIds !== undefined && shippingOrderSearchIds !== null) {
            queryParameters = queryParameters.set('shippingOrderSearchIds', <any>shippingOrderSearchIds);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<any>(`${this.basePath}/shippingOrderSearches`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get ShippingOrderResults previously consulted
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getConsultedShippingOrderResults(observe?: 'body', reportProgress?: boolean): Observable<Array<ShippingOrderResult>>;
    public getConsultedShippingOrderResults(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShippingOrderResult>>>;
    public getConsultedShippingOrderResults(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShippingOrderResult>>>;
    public getConsultedShippingOrderResults(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ShippingOrderResult>>(`${this.basePath}/shippingOrderResults/consulted`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get new offers count for each searches
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCountUnreadShippingOrderResult(observe?: 'body', reportProgress?: boolean): Observable<Array<ShippingOrderResultsNewOfferCount>>;
    public getCountUnreadShippingOrderResult(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShippingOrderResultsNewOfferCount>>>;
    public getCountUnreadShippingOrderResult(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShippingOrderResultsNewOfferCount>>>;
    public getCountUnreadShippingOrderResult(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ShippingOrderResultsNewOfferCount>>(`${this.basePath}/shippingOrderResults/unread/count`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get deleted marketplace offers
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDeletedMarketplaceOffers(observe?: 'body', reportProgress?: boolean): Observable<Array<MarketplaceOffer>>;
    public getDeletedMarketplaceOffers(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MarketplaceOffer>>>;
    public getDeletedMarketplaceOffers(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MarketplaceOffer>>>;
    public getDeletedMarketplaceOffers(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MarketplaceOffer>>(`${this.basePath}/marketplaceOffers/deleted`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get enabled marketplaces
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEnabledMarketplaces(observe?: 'body', reportProgress?: boolean): Observable<Array<Marketplace>>;
    public getEnabledMarketplaces(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Marketplace>>>;
    public getEnabledMarketplaces(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Marketplace>>>;
    public getEnabledMarketplaces(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Marketplace>>(`${this.basePath}/marketplaces`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get offer submitted on marketplaces
     * 
     * @param marketplaceOfferId MarketplaceOffer id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMarketplaceOfferDetail(marketplaceOfferId: number, observe?: 'body', reportProgress?: boolean): Observable<MarketplaceOfferDetail>;
    public getMarketplaceOfferDetail(marketplaceOfferId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MarketplaceOfferDetail>>;
    public getMarketplaceOfferDetail(marketplaceOfferId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MarketplaceOfferDetail>>;
    public getMarketplaceOfferDetail(marketplaceOfferId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (marketplaceOfferId === null || marketplaceOfferId === undefined) {
            throw new Error('Required parameter marketplaceOfferId was null or undefined when calling getMarketplaceOfferDetail.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<MarketplaceOfferDetail>(`${this.basePath}/marketplaceOffer/${encodeURIComponent(String(marketplaceOfferId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get offers submitted on marketplaces
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMarketplaceOffers(observe?: 'body', reportProgress?: boolean): Observable<Array<MarketplaceOffer>>;
    public getMarketplaceOffers(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MarketplaceOffer>>>;
    public getMarketplaceOffers(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MarketplaceOffer>>>;
    public getMarketplaceOffers(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MarketplaceOffer>>(`${this.basePath}/marketplaceOffers`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get operator by id
     * 
     * @param operatorId Operator id to fetch
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOperator(operatorId: number, observe?: 'body', reportProgress?: boolean): Observable<Operator>;
    public getOperator(operatorId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Operator>>;
    public getOperator(operatorId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Operator>>;
    public getOperator(operatorId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (operatorId === null || operatorId === undefined) {
            throw new Error('Required parameter operatorId was null or undefined when calling getOperator.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Operator>(`${this.basePath}/operator/${encodeURIComponent(String(operatorId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all operators
     * 
     * @param search Enventual search terms (format: search&#x3D;attribute1&#x3D;value1;attribute2!&#x3D;value2;attribute3IN(4,5,6))
     * @param filter Enventual filter terms (format: filter&#x3D;attribute1,attribute2)
     * @param sort Enventual sorting term (format: sort&#x3D;attribute1,asc)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOperators(search?: string, filter?: string, sort?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Operator>>;
    public getOperators(search?: string, filter?: string, sort?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Operator>>>;
    public getOperators(search?: string, filter?: string, sort?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Operator>>>;
    public getOperators(search?: string, filter?: string, sort?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (search !== undefined && search !== null) {
            queryParameters = queryParameters.set('search', <any>search);
        }
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<Operator>>(`${this.basePath}/operators`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get seized ShippingOrder detail
     * 
     * @param seizedShippingOrderId SeizedShippingOrder id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSeizedShippingOrder(seizedShippingOrderId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<SeizedShippingOrder>>;
    public getSeizedShippingOrder(seizedShippingOrderId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SeizedShippingOrder>>>;
    public getSeizedShippingOrder(seizedShippingOrderId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SeizedShippingOrder>>>;
    public getSeizedShippingOrder(seizedShippingOrderId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (seizedShippingOrderId === null || seizedShippingOrderId === undefined) {
            throw new Error('Required parameter seizedShippingOrderId was null or undefined when calling getSeizedShippingOrder.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<SeizedShippingOrder>>(`${this.basePath}/seizedShippingOrder/${encodeURIComponent(String(seizedShippingOrderId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get seized ShippingOrders
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSeizedShippingOrders(observe?: 'body', reportProgress?: boolean): Observable<Array<SeizedShippingOrder>>;
    public getSeizedShippingOrders(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SeizedShippingOrder>>>;
    public getSeizedShippingOrders(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SeizedShippingOrder>>>;
    public getSeizedShippingOrders(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<SeizedShippingOrder>>(`${this.basePath}/seizedShippingOrders`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all shipper scores
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getShipperScores(observe?: 'body', reportProgress?: boolean): Observable<Array<ShipperScore>>;
    public getShipperScores(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShipperScore>>>;
    public getShipperScores(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShipperScore>>>;
    public getShipperScores(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ShipperScore>>(`${this.basePath}/shipperScores`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get shipping order grouping with 2 results
     * 
     * @param shippingOrderResultId ShippingOrderResult id
     * @param shippingOrderResultComplementId ShippingOrderResult complement id
     * @param isWithoutToll Specify wether get route with (default) or without toll.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getShippingOrderGrouping(shippingOrderResultId: number, shippingOrderResultComplementId: number, isWithoutToll?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<ShippingOrderGrouping>>;
    public getShippingOrderGrouping(shippingOrderResultId: number, shippingOrderResultComplementId: number, isWithoutToll?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShippingOrderGrouping>>>;
    public getShippingOrderGrouping(shippingOrderResultId: number, shippingOrderResultComplementId: number, isWithoutToll?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShippingOrderGrouping>>>;
    public getShippingOrderGrouping(shippingOrderResultId: number, shippingOrderResultComplementId: number, isWithoutToll?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderResultId === null || shippingOrderResultId === undefined) {
            throw new Error('Required parameter shippingOrderResultId was null or undefined when calling getShippingOrderGrouping.');
        }

        if (shippingOrderResultComplementId === null || shippingOrderResultComplementId === undefined) {
            throw new Error('Required parameter shippingOrderResultComplementId was null or undefined when calling getShippingOrderGrouping.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (isWithoutToll !== undefined && isWithoutToll !== null) {
            queryParameters = queryParameters.set('isWithoutToll', <any>isWithoutToll);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ShippingOrderGrouping>>(`${this.basePath}/shippingOrderResultGrouping/${encodeURIComponent(String(shippingOrderResultId))}/${encodeURIComponent(String(shippingOrderResultComplementId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get shipping order detail
     * When possible, fetch also detail from external marketplace
     * @param shippingOrderResultId ShippingOrderResult id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getShippingOrderResult(shippingOrderResultId: number, observe?: 'body', reportProgress?: boolean): Observable<ShippingOrderResult>;
    public getShippingOrderResult(shippingOrderResultId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ShippingOrderResult>>;
    public getShippingOrderResult(shippingOrderResultId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ShippingOrderResult>>;
    public getShippingOrderResult(shippingOrderResultId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderResultId === null || shippingOrderResultId === undefined) {
            throw new Error('Required parameter shippingOrderResultId was null or undefined when calling getShippingOrderResult.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ShippingOrderResult>(`${this.basePath}/shippingOrderResult/${encodeURIComponent(String(shippingOrderResultId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get shipping order route
     * When Route has not yet been computed, compute it (cacheable and idempotent request)
     * @param shippingOrderResultId ShippingOrderResult id
     * @param isWithoutToll Specify wether get route with (default) or without toll.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getShippingOrderResultRoute(shippingOrderResultId: number, isWithoutToll?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Routes>;
    public getShippingOrderResultRoute(shippingOrderResultId: number, isWithoutToll?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Routes>>;
    public getShippingOrderResultRoute(shippingOrderResultId: number, isWithoutToll?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Routes>>;
    public getShippingOrderResultRoute(shippingOrderResultId: number, isWithoutToll?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderResultId === null || shippingOrderResultId === undefined) {
            throw new Error('Required parameter shippingOrderResultId was null or undefined when calling getShippingOrderResultRoute.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (isWithoutToll !== undefined && isWithoutToll !== null) {
            queryParameters = queryParameters.set('isWithoutToll', <any>isWithoutToll);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Routes>(`${this.basePath}/shippingOrderResult/${encodeURIComponent(String(shippingOrderResultId))}/route`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get ShippingOrderResults from a given ShippingOrderSearch
     * 
     * @param shippingOrderSearchId ShippingOrderSearch id for which get results
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getShippingOrderResults(shippingOrderSearchId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ShippingOrderResult>>;
    public getShippingOrderResults(shippingOrderSearchId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShippingOrderResult>>>;
    public getShippingOrderResults(shippingOrderSearchId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShippingOrderResult>>>;
    public getShippingOrderResults(shippingOrderSearchId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderSearchId === null || shippingOrderSearchId === undefined) {
            throw new Error('Required parameter shippingOrderSearchId was null or undefined when calling getShippingOrderResults.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ShippingOrderResult>>(`${this.basePath}/shippingOrderResults/${encodeURIComponent(String(shippingOrderSearchId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get ShippingOrderResults previously pushed via notifications
     * 
     * @param page page
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getShippingOrderResultsNotifications(page: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ShippingOrderResult>>;
    public getShippingOrderResultsNotifications(page: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShippingOrderResult>>>;
    public getShippingOrderResultsNotifications(page: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShippingOrderResult>>>;
    public getShippingOrderResultsNotifications(page: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getShippingOrderResultsNotifications.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ShippingOrderResult>>(`${this.basePath}/shippingOrderResults/notifications`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get shipping order search
     * 
     * @param shippingOrderSearchId ShippingOrderSearch id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getShippingOrderSearch(shippingOrderSearchId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ShippingOrderSearch>>;
    public getShippingOrderSearch(shippingOrderSearchId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShippingOrderSearch>>>;
    public getShippingOrderSearch(shippingOrderSearchId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShippingOrderSearch>>>;
    public getShippingOrderSearch(shippingOrderSearchId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderSearchId === null || shippingOrderSearchId === undefined) {
            throw new Error('Required parameter shippingOrderSearchId was null or undefined when calling getShippingOrderSearch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ShippingOrderSearch>>(`${this.basePath}/shippingOrderSearch/${encodeURIComponent(String(shippingOrderSearchId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get shipping orders search and perform search query
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getShippingOrderSearches(observe?: 'body', reportProgress?: boolean): Observable<Array<ShippingOrderSearch>>;
    public getShippingOrderSearches(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShippingOrderSearch>>>;
    public getShippingOrderSearches(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShippingOrderSearch>>>;
    public getShippingOrderSearches(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ShippingOrderSearch>>(`${this.basePath}/shippingOrderSearches`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all unread ShippingOrderResults
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUnreadShippingOrderResults(observe?: 'body', reportProgress?: boolean): Observable<Array<ShippingOrderResult>>;
    public getUnreadShippingOrderResults(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShippingOrderResult>>>;
    public getUnreadShippingOrderResults(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShippingOrderResult>>>;
    public getUnreadShippingOrderResults(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ShippingOrderResult>>(`${this.basePath}/shippingOrderResults/unread`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get marketplaces on which user has entered his credentials
     * 
     * @param userId User id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserMarketplace(userId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<MarketplaceUser>>;
    public getUserMarketplace(userId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MarketplaceUser>>>;
    public getUserMarketplace(userId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MarketplaceUser>>>;
    public getUserMarketplace(userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserMarketplace.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<MarketplaceUser>>(`${this.basePath}/marketplaces/userId/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * All ShippingOrderResult from all ShippingOrderSearch will be marked as read
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public markAllResultsAsRead(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public markAllResultsAsRead(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public markAllResultsAsRead(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public markAllResultsAsRead(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/shippingOrderResults/markAllAsRead`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * All ShippingOrderResult from given ShippingOrderSearch will be marked as read
     * 
     * @param shippingOrderSearchId ShippingOrderSearch from which ShippingOrderResults will be marked as read
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public markAllResultsFromShippingOrderSearchAsRead(shippingOrderSearchId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public markAllResultsFromShippingOrderSearchAsRead(shippingOrderSearchId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public markAllResultsFromShippingOrderSearchAsRead(shippingOrderSearchId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public markAllResultsFromShippingOrderSearchAsRead(shippingOrderSearchId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderSearchId === null || shippingOrderSearchId === undefined) {
            throw new Error('Required parameter shippingOrderSearchId was null or undefined when calling markAllResultsFromShippingOrderSearchAsRead.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/shippingOrderResults/markAllAsRead/shippingOrderSearch/${encodeURIComponent(String(shippingOrderSearchId))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Login operator user
     * 
     * @param login Identifier and password matching a B2P user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public operatorLogin(login: Login2, observe?: 'body', reportProgress?: boolean): Observable<OperatorUser>;
    public operatorLogin(login: Login2, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<OperatorUser>>;
    public operatorLogin(login: Login2, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<OperatorUser>>;
    public operatorLogin(login: Login2, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling operatorLogin.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<OperatorUser>(`${this.basePath}/operatorLogin`,
            login,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Login operator user without using sessions
     * Useful for mobile devices or machine to machine
     * @param login Identifier and password matching a B2P user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public operatorLoginStateless(login: Login1, observe?: 'body', reportProgress?: boolean): Observable<OperatorUser>;
    public operatorLoginStateless(login: Login1, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<OperatorUser>>;
    public operatorLoginStateless(login: Login1, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<OperatorUser>>;
    public operatorLoginStateless(login: Login1, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling operatorLoginStateless.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<OperatorUser>(`${this.basePath}/operatorLogin/stateless`,
            login,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patch operator
     * 
     * @param operatorId Operator id to delete
     * @param body Operatorobject
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchOperator(operatorId: number, body: Operator, observe?: 'body', reportProgress?: boolean): Observable<Operator>;
    public patchOperator(operatorId: number, body: Operator, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Operator>>;
    public patchOperator(operatorId: number, body: Operator, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Operator>>;
    public patchOperator(operatorId: number, body: Operator, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (operatorId === null || operatorId === undefined) {
            throw new Error('Required parameter operatorId was null or undefined when calling patchOperator.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchOperator.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<Operator>(`${this.basePath}/operator/${encodeURIComponent(String(operatorId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Perform shippingOrderSearch and return results with scoring (which is performed synchronously)
     * 
     * @param shippingOrderSearchId ShippingOrderSearch id for which perform search
     * @param page page
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public performPaginatedSearch(shippingOrderSearchId: number, page: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ShippingOrderResult>>;
    public performPaginatedSearch(shippingOrderSearchId: number, page: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShippingOrderResult>>>;
    public performPaginatedSearch(shippingOrderSearchId: number, page: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShippingOrderResult>>>;
    public performPaginatedSearch(shippingOrderSearchId: number, page: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderSearchId === null || shippingOrderSearchId === undefined) {
            throw new Error('Required parameter shippingOrderSearchId was null or undefined when calling performPaginatedSearch.');
        }

        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling performPaginatedSearch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<Array<ShippingOrderResult>>(`${this.basePath}/shippingOrderSearch/${encodeURIComponent(String(shippingOrderSearchId))}/performSearch/paginated`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Perform shippingOrderSearch and return results. Scoring is asynchronous and will be provided through websocket
     * 
     * @param shippingOrderSearchId ShippingOrderSearch id for which perform search
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public performSearchWithAsynchronousScoring(shippingOrderSearchId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ShippingOrderResult>>;
    public performSearchWithAsynchronousScoring(shippingOrderSearchId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShippingOrderResult>>>;
    public performSearchWithAsynchronousScoring(shippingOrderSearchId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShippingOrderResult>>>;
    public performSearchWithAsynchronousScoring(shippingOrderSearchId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderSearchId === null || shippingOrderSearchId === undefined) {
            throw new Error('Required parameter shippingOrderSearchId was null or undefined when calling performSearchWithAsynchronousScoring.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<Array<ShippingOrderResult>>(`${this.basePath}/shippingOrderSearch/${encodeURIComponent(String(shippingOrderSearchId))}/performSearch/withAsynchronousScoring`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Publish given MarketplaceOffer
     * 
     * @param marketplaceOfferId Id of the MarketplaceOffer to publish
     * @param marketplaceIds Comma-separated list of ids of Marketplaces to publish MarketplaceOffer on.
     * @param body Eventual marketplace publication metadata
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public publishMarketplaceOffer(marketplaceOfferId: number, marketplaceIds: string, body?: MarketplaceMetadata, observe?: 'body', reportProgress?: boolean): Observable<Array<MarketplaceOfferPublication>>;
    public publishMarketplaceOffer(marketplaceOfferId: number, marketplaceIds: string, body?: MarketplaceMetadata, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MarketplaceOfferPublication>>>;
    public publishMarketplaceOffer(marketplaceOfferId: number, marketplaceIds: string, body?: MarketplaceMetadata, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MarketplaceOfferPublication>>>;
    public publishMarketplaceOffer(marketplaceOfferId: number, marketplaceIds: string, body?: MarketplaceMetadata, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (marketplaceOfferId === null || marketplaceOfferId === undefined) {
            throw new Error('Required parameter marketplaceOfferId was null or undefined when calling publishMarketplaceOffer.');
        }

        if (marketplaceIds === null || marketplaceIds === undefined) {
            throw new Error('Required parameter marketplaceIds was null or undefined when calling publishMarketplaceOffer.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<MarketplaceOfferPublication>>(`${this.basePath}/marketplaceOffer/${encodeURIComponent(String(marketplaceOfferId))}/publish/${encodeURIComponent(String(marketplaceIds))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a MarketplaceOffer
     * 
     * @param marketplaceOfferId MarketplaceOffer id
     * @param body MarketplaceOffer object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putMarketplaceOffer(marketplaceOfferId: number, body: MarketplaceOffer, observe?: 'body', reportProgress?: boolean): Observable<MarketplaceOffer>;
    public putMarketplaceOffer(marketplaceOfferId: number, body: MarketplaceOffer, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MarketplaceOffer>>;
    public putMarketplaceOffer(marketplaceOfferId: number, body: MarketplaceOffer, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MarketplaceOffer>>;
    public putMarketplaceOffer(marketplaceOfferId: number, body: MarketplaceOffer, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (marketplaceOfferId === null || marketplaceOfferId === undefined) {
            throw new Error('Required parameter marketplaceOfferId was null or undefined when calling putMarketplaceOffer.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putMarketplaceOffer.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<MarketplaceOffer>(`${this.basePath}/marketplaceOffer/${encodeURIComponent(String(marketplaceOfferId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Change score for given shipper company name
     * 
     * @param body ShipperScore object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putShipperScore(body: ShipperScore, observe?: 'body', reportProgress?: boolean): Observable<ShipperScore>;
    public putShipperScore(body: ShipperScore, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ShipperScore>>;
    public putShipperScore(body: ShipperScore, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ShipperScore>>;
    public putShipperScore(body: ShipperScore, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putShipperScore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ShipperScore>(`${this.basePath}/shipperScore`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Patch shipping orders search
     * 
     * @param shippingOrderSearchId Search id to patch
     * @param body ShippingOrderSearch
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putShippingOrderSearch(shippingOrderSearchId: number, body: ShippingOrderSearch, observe?: 'body', reportProgress?: boolean): Observable<ShippingOrderSearch>;
    public putShippingOrderSearch(shippingOrderSearchId: number, body: ShippingOrderSearch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ShippingOrderSearch>>;
    public putShippingOrderSearch(shippingOrderSearchId: number, body: ShippingOrderSearch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ShippingOrderSearch>>;
    public putShippingOrderSearch(shippingOrderSearchId: number, body: ShippingOrderSearch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderSearchId === null || shippingOrderSearchId === undefined) {
            throw new Error('Required parameter shippingOrderSearchId was null or undefined when calling putShippingOrderSearch.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putShippingOrderSearch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ShippingOrderSearch>(`${this.basePath}/shippingOrderSearch/${encodeURIComponent(String(shippingOrderSearchId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Refresh given MarketplaceOffer on all Marketplaces
     * 
     * @param marketplaceOfferId Id of the MarketplaceOffer to refresh
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public refreshMarketplaceOffer(marketplaceOfferId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public refreshMarketplaceOffer(marketplaceOfferId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public refreshMarketplaceOffer(marketplaceOfferId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public refreshMarketplaceOffer(marketplaceOfferId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (marketplaceOfferId === null || marketplaceOfferId === undefined) {
            throw new Error('Required parameter marketplaceOfferId was null or undefined when calling refreshMarketplaceOffer.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/marketplaceOffer/${encodeURIComponent(String(marketplaceOfferId))}/refresh`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Register new Carrier
     * 
     * @param body RegisterCarrier object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registerCarrier(body: RegisterCarrier, observe?: 'body', reportProgress?: boolean): Observable<RegisterCarrier>;
    public registerCarrier(body: RegisterCarrier, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RegisterCarrier>>;
    public registerCarrier(body: RegisterCarrier, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RegisterCarrier>>;
    public registerCarrier(body: RegisterCarrier, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling registerCarrier.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<RegisterCarrier>(`${this.basePath}/registerCarrier`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search eventual complementary shipping orders
     * 
     * @param shippingOrderResultId ShippingOrderResult id to search complements for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public searchComplements(shippingOrderResultId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ShippingOrderResult>>;
    public searchComplements(shippingOrderResultId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ShippingOrderResult>>>;
    public searchComplements(shippingOrderResultId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ShippingOrderResult>>>;
    public searchComplements(shippingOrderResultId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderResultId === null || shippingOrderResultId === undefined) {
            throw new Error('Required parameter shippingOrderResultId was null or undefined when calling searchComplements.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<ShippingOrderResult>>(`${this.basePath}/shippingOrderResult/${encodeURIComponent(String(shippingOrderResultId))}/searchComplements`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Seize existing shippingOrderResult
     * 
     * @param shippingOrderResultId ShippingOrderResult id
     * @param body Negociated price
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public seizeShippingOrderResult(shippingOrderResultId: number, body: Body, observe?: 'body', reportProgress?: boolean): Observable<SeizedShippingOrder>;
    public seizeShippingOrderResult(shippingOrderResultId: number, body: Body, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SeizedShippingOrder>>;
    public seizeShippingOrderResult(shippingOrderResultId: number, body: Body, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SeizedShippingOrder>>;
    public seizeShippingOrderResult(shippingOrderResultId: number, body: Body, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderResultId === null || shippingOrderResultId === undefined) {
            throw new Error('Required parameter shippingOrderResultId was null or undefined when calling seizeShippingOrderResult.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling seizeShippingOrderResult.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<SeizedShippingOrder>(`${this.basePath}/seizeShippingOrderResult/${encodeURIComponent(String(shippingOrderResultId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send contact mail to shipper
     * 
     * @param shippingOrderResultId ShippingOrderResult from which to send mail
     * @param body MailContact
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendMailContact(shippingOrderResultId: number, body: MailContact, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public sendMailContact(shippingOrderResultId: number, body: MailContact, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public sendMailContact(shippingOrderResultId: number, body: MailContact, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public sendMailContact(shippingOrderResultId: number, body: MailContact, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderResultId === null || shippingOrderResultId === undefined) {
            throw new Error('Required parameter shippingOrderResultId was null or undefined when calling sendMailContact.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling sendMailContact.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/shippingOrderResult/${encodeURIComponent(String(shippingOrderResultId))}/sendMailContact`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Enable/disable ShippingOrderSearch activation
     * 
     * @param shippingOrderSearchId Search id to patch
     * @param body ShippingOrderSearch
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toggleActivateShippingOrderSearch(shippingOrderSearchId: number, body: ShippingOrderSearch, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public toggleActivateShippingOrderSearch(shippingOrderSearchId: number, body: ShippingOrderSearch, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public toggleActivateShippingOrderSearch(shippingOrderSearchId: number, body: ShippingOrderSearch, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public toggleActivateShippingOrderSearch(shippingOrderSearchId: number, body: ShippingOrderSearch, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderSearchId === null || shippingOrderSearchId === undefined) {
            throw new Error('Required parameter shippingOrderSearchId was null or undefined when calling toggleActivateShippingOrderSearch.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling toggleActivateShippingOrderSearch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<any>(`${this.basePath}/shippingOrderSearch/${encodeURIComponent(String(shippingOrderSearchId))}/toggleActivate`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Trigger a push to dial a phone number on a mobile device
     * 
     * @param shippingOrderResultId ShippingOrderResult id for which trigger a dial
     * @param phoneAttribute Property in model where to take phone number to dial
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public triggerShippingOrderResultDialPhoneNumber(shippingOrderResultId: number, phoneAttribute: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public triggerShippingOrderResultDialPhoneNumber(shippingOrderResultId: number, phoneAttribute: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public triggerShippingOrderResultDialPhoneNumber(shippingOrderResultId: number, phoneAttribute: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public triggerShippingOrderResultDialPhoneNumber(shippingOrderResultId: number, phoneAttribute: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (shippingOrderResultId === null || shippingOrderResultId === undefined) {
            throw new Error('Required parameter shippingOrderResultId was null or undefined when calling triggerShippingOrderResultDialPhoneNumber.');
        }

        if (phoneAttribute === null || phoneAttribute === undefined) {
            throw new Error('Required parameter phoneAttribute was null or undefined when calling triggerShippingOrderResultDialPhoneNumber.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/shippingOrderResult/${encodeURIComponent(String(shippingOrderResultId))}/triggerDialPhoneNumber/phoneAttribute/${encodeURIComponent(String(phoneAttribute))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add login/password user to connect to a marketplace
     * 
     * @param body MarketplaceUser object
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateOrCreateMarketplaceUser(body: MarketplaceUser, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateOrCreateMarketplaceUser(body: MarketplaceUser, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateOrCreateMarketplaceUser(body: MarketplaceUser, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateOrCreateMarketplaceUser(body: MarketplaceUser, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateOrCreateMarketplaceUser.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/marketplaceUser`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Withdraw given MarketplaceOffer from given Marketplaces
     * 
     * @param marketplaceOfferId Id of the MarketplaceOffer to withdraw
     * @param marketplaceIds Comma-separated list of ids of Marketplaces to withdraw MarketplaceOffer off.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public withdrawMarketplaceOffer(marketplaceOfferId: number, marketplaceIds: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MarketplaceOfferPublication>>;
    public withdrawMarketplaceOffer(marketplaceOfferId: number, marketplaceIds: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MarketplaceOfferPublication>>>;
    public withdrawMarketplaceOffer(marketplaceOfferId: number, marketplaceIds: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MarketplaceOfferPublication>>>;
    public withdrawMarketplaceOffer(marketplaceOfferId: number, marketplaceIds: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (marketplaceOfferId === null || marketplaceOfferId === undefined) {
            throw new Error('Required parameter marketplaceOfferId was null or undefined when calling withdrawMarketplaceOffer.');
        }

        if (marketplaceIds === null || marketplaceIds === undefined) {
            throw new Error('Required parameter marketplaceIds was null or undefined when calling withdrawMarketplaceOffer.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<Array<MarketplaceOfferPublication>>(`${this.basePath}/marketplaceOffer/${encodeURIComponent(String(marketplaceOfferId))}/withdraw/${encodeURIComponent(String(marketplaceIds))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
